/**
 * @file
 * @author Ryan Little
 */

#ifndef ZNROTATIONCRYPTOSYSTEM_CRYPTOSYSTEM_H
#define ZNROTATIONCRYPTOSYSTEM_CRYPTOSYSTEM_H

#include "sampling.h"
#include "utils.h"
#include <math.h>
#include "eigenmvn/eigenmvn.h"

#define EPS 1e-40f

typedef Eigen::Matrix<mpfr::mpreal, Eigen::Dynamic, Eigen::Dynamic> MatrixXm;
typedef Eigen::Vector<mpfr::mpreal, Eigen::Dynamic> VectorXm;

/**
 * Class to perform key generation, encryption, and decryption.
 */
class Cryptosystem {
private:

    /**
     * Private key, to be generated by Cryptosystem::generate_keys().
     */
    MatrixXm B;

    /**
    * Public key, to be generated by Cryptosystem::generate_keys().
    */
    MatrixXm G_inv;

    /**
    * Dimension.
    */
    int n;

    /**
     * Number of vectors to sample from discrete Gaussian in key generation. Must be >= n.
     */
    int k;

    /**
     * Noise parameter used in encryption.
     */
    double r;

    /**
     * Parameter controlling length of public key basis, used in key generation.
     */
    double s;

    /**
     * Distance threshold used in decryption.
     */
    double d;

    /**
     * Redundency parameter
     */
    int h;

public:
    Cryptosystem(int n, int k, double r, double s, double d) : n(n), k(k), r(r), s(s), d(d) {}

    /**
    * Generate public and private key pair. Results are stored in class members B (for private key)
    * and G_inv (for public key).
    */
    void generate_keys();

    /**
    * Encrypts a bit under a public key. If b=2, ciphertext is sampled uniformly from [0,1)^n.
     * Otherwise, ciphertext is sampled from continuous Gaussian with covariance matrix r^2*G^{-1}, and taken modulo 1.
     *
     * @param pk The public key, G^{-1}
     * @param b  Plaintext bit to be encrypted
     * @return   The ciphertext
     */
    VectorXm encrypt(MatrixXm pk, bool b);

    /**
     * Decrypts a ciphertext under a private key. Computes t := c*B where c is the ciphertext and B is the private key,
     * and returns true if the distance between t and the integer lattice is >d, otherwise returns false.
     *
     * @param sk The private key, i.e. B
     * @param c  The ciphertext
     * @return   The decrypted ciphertext
     */
    bool decrypt(MatrixXm sk, VectorXm c);

    /**
     * Encodes a bit as a m-repetition code (by repeating it m times), and encrypts each repetition separately under
     * a given public key in the standard way. The ciphertexts are returned as a vector of length m.
     *
     * @param pk The public key, G^{-1}
     * @param b  Plaintext bit to be encrypted
     * @param m  Number of repetitions in repetition code. Should be odd.
     * @return   A vector of length m, where each entry is a ciphertext of bit b under key pk.
     */
    std::vector<VectorXm> encrypt_rep_code(MatrixXm pk, bool b, int m);

    /**
     * Decrypts and decodes a length m repetition code of ciphertexts. Returns the value of the majority of decrypted
     * ciphertexts (assuming odd m).
     *
     * @param sk The private key
     * @param c  Vector of ciphertexts, of length m
     * @param m  Number of repetitions in repetition code. Should be odd.
     * @return   The decrypted and decoded ciphertext
     */
    bool decrypt_rep_code(MatrixXm sk, std::vector<VectorXm> c, int m);

    const MatrixXm &getB() { return B; }

    const MatrixXm &getG_inv() { return G_inv; }

    void set_B(const MatrixXm &b) { this->B = b; }

    void set_G_inv(MatrixXm &g_inv) { this->G_inv = g_inv; }

    void set_n(int n) { this->n = n; }

    void set_k(int k) { this->k = k; }

    void set_r(double r) { this->r = r; }

    void set_s(double s) { this->s = s; }

    void set_d(double d) { this->d = d; }
};

#endif //ZNROTATIONCRYPTOSYSTEM_CRYPTOSYSTEM_H
